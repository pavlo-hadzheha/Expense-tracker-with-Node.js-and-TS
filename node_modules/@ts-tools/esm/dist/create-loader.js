import { readFileSync } from 'node:fs';
import { pathToFileURL, fileURLToPath } from 'node:url';
import ts from 'typescript';
const { Extension } = ts;
const isTypescriptFile = (url) => url.endsWith(Extension.Ts) ||
    url.endsWith(Extension.Tsx) ||
    url.endsWith(Extension.Mts) ||
    url.endsWith(Extension.Cts);
const definitionExtensions = new Set([Extension.Dts, Extension.Dcts, Extension.Dmts]);
export function createLoader({ compilerOptions, cwd }) {
    const moduleResolutionCache = ts.createModuleResolutionCache(cwd, ts.sys.useCaseSensitiveFileNames ? (s) => s : (s) => s.toLowerCase(), compilerOptions);
    const resolve = (specifier, context, defaultResolve) => {
        const { parentURL } = context;
        if (parentURL !== undefined && isTypescriptFile(parentURL)) {
            const { resolvedModule } = ts.resolveModuleName(specifier, fileURLToPath(parentURL), compilerOptions, ts.sys, moduleResolutionCache);
            if (resolvedModule && !definitionExtensions.has(resolvedModule.extension)) {
                return {
                    url: pathToFileURL(resolvedModule.resolvedFileName).href,
                    shortCircuit: true,
                };
            }
        }
        return defaultResolve(specifier, context, defaultResolve);
    };
    const load = (url, context, defaultTransformSource) => {
        if (isTypescriptFile(url)) {
            const filePath = fileURLToPath(url);
            const source = readFileSync(filePath, 'utf8');
            return {
                source: ts.transpileModule(source, {
                    fileName: filePath,
                    compilerOptions,
                }).outputText,
                format: 'module',
                shortCircuit: true,
            };
        }
        else {
            return defaultTransformSource(url, context, defaultTransformSource);
        }
    };
    return {
        resolve,
        load,
    };
}
//# sourceMappingURL=create-loader.js.map